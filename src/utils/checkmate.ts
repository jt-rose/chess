import { Board, updateBoard } from "./board";
import { PlayerColor } from "./pieces";
import {
  getPiecesOfSameColor,
  getOffensiveRange,
  mapPossibleMoves,
  findKingPosition,
  getOppositeColor,
  convertMovementOptionsToArray,
  mapSinglePiecePossibleMoves,
} from "./utils";

// get offensive range and see if opposing king is in danger
const putKingInCheck = (offensiveColor: PlayerColor, board: Board): boolean => {
  const offensiveMovementOptions = getOffensiveRange(offensiveColor, board);

  // pick out position of defending king
  const kingPosition = board.findIndex(
    (p) => p?.name === "king" && p.color !== offensiveColor
  );

  // check if king is within range of attack
  const isKingInDanger = offensiveMovementOptions.includes(kingPosition);

  return isKingInDanger;
};

const findMovementOptionsByPiece = (color: PlayerColor, board: Board) => {
  const pieces = getPiecesOfSameColor(color, board);
  const movementOptionsByPiece = pieces
    .map((piece) => ({
      ...piece,
      movementOptions: piece.getMovementOptions({
        position: piece.index,
        color: piece.color,
        board,
      }),
    }))
    // disregard movement direction and grab all possible positions per piece
    .map((p) => ({
      ...p,
      movementOptions: convertMovementOptionsToArray(p.movementOptions),
    }));

  return movementOptionsByPiece;
};

// offensive options can change if king or other pieces defeat attacking pieces
// or even just move in the way
const checkMate = (offensiveColor: PlayerColor, board: Board) => {
  // find movement positions of offensiveColor for the next turn
  const offensiveMovements = findMovementOptionsByPiece(offensiveColor, board);

  // find defending king's position
  const kingPosition = findKingPosition(offensiveColor, board);

  // check if king's position can be reached by the offensive color's movement options
  const kingInDanger = offensiveMovements.find((piece) =>
    piece.movementOptions.includes(kingPosition)
  );

  // if king is not in check, return false
  if (!kingInDanger) {
    return false;
    // otherwise, determine if checkmate
  } else {
    // if king in check, find all possible movement options for the king and his allies this turn
    const kingColor = getOppositeColor(offensiveColor);
    const kingAllies = getPiecesOfSameColor(kingColor, board).filter(
      (piece) => piece.name !== "king"
    );

    // map out possible board updates caused by king moving to new position
    // store the king's new position with the results
    const kingMovementResponses = mapSinglePiecePossibleMoves(
      kingPosition,
      board
    ).movementOptions.map((newPosition) => ({
      newPosition,
      board: updateBoard(kingPosition, newPosition, board),
    }));

    // map out possible board updates caused by allies of the defending king moving
    // find possible moves for each piece
    const allyMovementResponses = kingAllies
      .map((piece) => mapSinglePiecePossibleMoves(piece.index, board))
      // generate updated board based on playing out possible movements for each piece
      .map((pieceWithMO) =>
        pieceWithMO.movementOptions.map((newPosition) =>
          updateBoard(pieceWithMO.index, newPosition, board)
        )
      )
      // flatten to a Board[] array
      .flat();

    // for each board generated by the king moving, simulate all possible responses by the opponent
    // and check if each new board created by the king's movement has at least one response that can capture him
    // at his new position, determining a checkmate
    const kingInDangerAfterKingMoves = kingMovementResponses.every((kingMO) => {
      const newBoard = kingMO.board;
      // map out responses
      const offensiveResponses = findMovementOptionsByPiece(
        offensiveColor,
        board
      );
      // check if any of the resulting boards still have king under threat
      const kingStillInDanger = offensiveResponses.some((response) =>
        response.movementOptions.includes(kingMO.newPosition)
      );
      return kingStillInDanger;
    });

    // for each board generated by one of the king's allies moving
    // check to see if a possible response can still capture the king
    // determining a checkmate
    const kingInDangerAfterAlliesMove = allyMovementResponses.every(
      (newBoard) => {
        // map out responses
        const offensiveResponses = findMovementOptionsByPiece(
          offensiveColor,
          newBoard
        );

        // check if any of the resulting boards still have king under threat
        const kingStillInDanger = offensiveResponses.some((response) =>
          response.movementOptions.includes(kingPosition)
        );
        return kingStillInDanger;
      }
    );

    const isCheckmate =
      kingInDangerAfterKingMoves && kingInDangerAfterAlliesMove;
    return isCheckmate;
  }
};
// enpassant
